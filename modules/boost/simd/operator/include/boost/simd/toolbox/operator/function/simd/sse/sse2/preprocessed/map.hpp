namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints64_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1]))); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< double_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1]))); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< float_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3]))); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints32_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3]))); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints16_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4] , a4[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5] , a4[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6] , a4[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7] , a4[ 7]))); } }; } } }
namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 8])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 9])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 10])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 11])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 12])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 13])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 14])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 15]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8] , a3[ 8])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9] , a3[ 9])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10] , a3[ 10])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11] , a3[ 11])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12] , a3[ 12])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13] , a3[ 13])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14] , a3[ 14])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15] , a3[ 15]))); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template<class A0 , class A1 , class A2 , class A3 , class A4> inline boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_>) , tag::cpu_ > dispatching( boost::simd::tag::map_ const&, tag::cpu_ const& , boost::dispatch::meta::unspecified_<A0> const& , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> const& , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> const& , adl_helper = adl_helper() ) { boost :: simd :: ext :: implement< boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ > that; return that; } } } } namespace boost { namespace simd { namespace ext { template< class A0 , class A1 , class A2 , class A3 , class A4 , class Dummy > struct implement < boost::simd::tag::map_(boost::dispatch::meta::unspecified_<A0> , boost::dispatch::meta::simd_< ints8_<A1>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A2>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A3>,boost::simd::tag::sse_> , boost::dispatch::meta::simd_< arithmetic_<A4>,boost::simd::tag::sse_> ) , tag::cpu_ , Dummy > { typedef typename dispatch::meta:: result_of< A0 const( typename meta::scalar_of<A1>::type , typename meta::scalar_of<A2>::type , typename meta::scalar_of<A3>::type , typename meta::scalar_of<A4>::type ) >::type rtype; typedef typename details:: as_native< A0 , rtype , typename meta::scalar_of<A1>::type >::type stype; typedef boost::simd::native<stype, boost::simd::tag::sse_> result_type; inline result_type operator()( A0 const& a0 , A1 const& a1 , A2 const& a2 , A3 const& a3 , A4 const& a4 ) const { return boost::simd::make<result_type>(boost::simd::details::maybe_genmask<stype>(a0(a1[ 0] , a2[ 0] , a3[ 0] , a4[ 0])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 1] , a2[ 1] , a3[ 1] , a4[ 1])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 2] , a2[ 2] , a3[ 2] , a4[ 2])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 3] , a2[ 3] , a3[ 3] , a4[ 3])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 4] , a2[ 4] , a3[ 4] , a4[ 4])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 5] , a2[ 5] , a3[ 5] , a4[ 5])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 6] , a2[ 6] , a3[ 6] , a4[ 6])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 7] , a2[ 7] , a3[ 7] , a4[ 7])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 8] , a2[ 8] , a3[ 8] , a4[ 8])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 9] , a2[ 9] , a3[ 9] , a4[ 9])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 10] , a2[ 10] , a3[ 10] , a4[ 10])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 11] , a2[ 11] , a3[ 11] , a4[ 11])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 12] , a2[ 12] , a3[ 12] , a4[ 12])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 13] , a2[ 13] , a3[ 13] , a4[ 13])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 14] , a2[ 14] , a3[ 14] , a4[ 14])) , boost::simd::details::maybe_genmask<stype>(a0(a1[ 15] , a2[ 15] , a3[ 15] , a4[ 15]))); } }; } } }
