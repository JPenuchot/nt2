namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X0 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X0 > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X0 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0> struct result<This(_Func, _A0)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef simd::native<rtype, X0> type; static type call( Func const& f , _A0 & a0 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(a0[i]), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , _A0 & a0 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(a0[i]); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 ) >::type operator()(Func const& f, _A0 & a0) { return result< implement( Func const& , _A0 & a0 ) >::impl_::call(f, a0); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X0 , class A1 , class X1 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X0 > const , simd_< unspecified_<A1>, X1 > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X0 , class A1 , class X1 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1> struct result<This(_Func, _A0 , _A1)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef simd::native<rtype, typename details::best_ext< X0, X1 >::type> type; static type call( Func const& f , _A0 & a0 , _A1 & a1 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i]), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , _A0 & a0 , _A1 & a1 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(a0[i] , a1[i]); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 ) >::impl_::call(f, a0 , a1); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X0 > const , simd_< unspecified_<A1>, X1 > const , simd_< unspecified_<A2>, X2 > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2> struct result<This(_Func, _A0 , _A1 , _A2)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef simd::native<rtype, typename details::best_ext< typename details::best_ext< X0, X1 >::type, X2 >::type> type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i]), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(a0[i] , a1[i] , a2[i]); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 ) >::impl_::call(f, a0 , a1 , a2); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 , class A3 , class X3 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X0 > const , simd_< unspecified_<A1>, X1 > const , simd_< unspecified_<A2>, X2 > const , simd_< unspecified_<A3>, X3 > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 , class A3 , class X3 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3> struct result<This(_Func, _A0 , _A1 , _A2 , _A3)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef simd::native<rtype, typename details::best_ext< typename details::best_ext< typename details::best_ext< X0, X1 >::type, X2 >::type, X3 >::type> type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i] , a3[i]), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(a0[i] , a1[i] , a2[i] , a3[i]); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2 , class _A3> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 ) >::impl_::call(f, a0 , a1 , a2 , a3); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 , class A3 , class X3 , class A4 , class X4 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > , simd_< unspecified_<A4>, X4 > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X0 > const , simd_< unspecified_<A1>, X1 > const , simd_< unspecified_<A2>, X2 > const , simd_< unspecified_<A3>, X3 > const , simd_< unspecified_<A4>, X4 > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > , simd_< unspecified_<A4>, X4 > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 , class A3 , class X3 , class A4 , class X4 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > , simd_< unspecified_<A4>, X4 > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3 , class _A4> struct result<This(_Func, _A0 , _A1 , _A2 , _A3 , _A4)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type , typename meta::scalar_of<_A4>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef simd::native<rtype, typename details::best_ext< typename details::best_ext< typename details::best_ext< typename details::best_ext< X0, X1 >::type, X2 >::type, X3 >::type, X4 >::type> type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i]), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i]); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 ) >::impl_::call(f, a0 , a1 , a2 , a3 , a4); } }; } } } namespace boost { namespace simd { namespace ext { } } } namespace boost { namespace dispatch { namespace meta { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 , class A3 , class X3 , class A4 , class X4 , class A5 , class X5 > BOOST_FORCEINLINE :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > , simd_< unspecified_<A4>, X4 > , simd_< unspecified_<A5>, X5 > ) , tag::cpu_ > dispatching( boost::simd::tag::map_, tag::cpu_ , unspecified_<Func> const , simd_< unspecified_<A0>, X0 > const , simd_< unspecified_<A1>, X1 > const , simd_< unspecified_<A2>, X2 > const , simd_< unspecified_<A3>, X3 > const , simd_< unspecified_<A4>, X4 > const , simd_< unspecified_<A5>, X5 > const , adl_helper = adl_helper() ) { return :: boost :: simd :: ext :: implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > , simd_< unspecified_<A4>, X4 > , simd_< unspecified_<A5>, X5 > ) , tag::cpu_ >(); } } } } namespace boost { namespace simd { namespace ext { template< class Func , class A0 , class X0 , class A1 , class X1 , class A2 , class X2 , class A3 , class X3 , class A4 , class X4 , class A5 , class X5 > struct implement< boost::simd::tag::map_ ( unspecified_<Func> , simd_< unspecified_<A0>, X0 > , simd_< unspecified_<A1>, X1 > , simd_< unspecified_<A2>, X2 > , simd_< unspecified_<A3>, X3 > , simd_< unspecified_<A4>, X4 > , simd_< unspecified_<A5>, X5 > ) , tag::cpu_ > { template<class Sig> struct result; template<class This, class _Func, class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> struct result<This(_Func, _A0 , _A1 , _A2 , _A3 , _A4 , _A5)> { typedef typename dispatch::meta:: result_of< Func const( typename meta::scalar_of<_A0>::type , typename meta::scalar_of<_A1>::type , typename meta::scalar_of<_A2>::type , typename meta::scalar_of<_A3>::type , typename meta::scalar_of<_A4>::type , typename meta::scalar_of<_A5>::type ) >::type rtype; template<class rtype, class Dummy = void> struct impl { typedef simd::native<rtype, typename details::best_ext< typename details::best_ext< typename details::best_ext< typename details::best_ext< typename details::best_ext< X0, X1 >::type, X2 >::type, X3 >::type, X4 >::type, X5 >::type> type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) { type that; for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) insert(f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i] , a5[i]), that, i); return that; } }; template<class Dummy> struct impl<void, Dummy> { typedef void type; static type call( Func const& f , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) { for(size_t i = 0; i != meta::cardinal_of<A0>::value; ++i) f(a0[i] , a1[i] , a2[i] , a3[i] , a4[i] , a5[i]); } }; typedef impl<rtype> impl_; typedef typename impl_::type type; }; template<class _A0 , class _A1 , class _A2 , class _A3 , class _A4 , class _A5> BOOST_FORCEINLINE typename result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) >::type operator()(Func const& f, _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5) { return result< implement( Func const& , _A0 & a0 , _A1 & a1 , _A2 & a2 , _A3 & a3 , _A4 & a4 , _A5 & a5 ) >::impl_::call(f, a0 , a1 , a2 , a3 , a4 , a5); } }; } } }
